import
  constants
  Library/Data/SwitchCase
  Library/Control/Error/ArgumentError
  Library/Control/Error/NotImplementedError
.

##:callShorthand ()

var compose_call is \:fn0:fn1 \:arg fn0 applyTo: (fn1 applyTo: arg).

var Colors is Object cnew: {
  my cache is Map new on: 'at:' do: {:key
    var self is const me.
    var cself is me.
    ^((var v is me `at: key) isNil not) either: {\ v. } or: {
      cself put: (var c is self message: 'color' arguments: key) at: key.
      ^c.
    }.
  }.
  mode => 256.
  on: 'backendType' do: {\ \HTML. }.
}.

Colors on: 'new' do: {
  thisBlock error: ArgumentError $ 'Colors may not be instantiated'.
}.
Colors on: 'cnew:' do: {
  thisBlock error: ArgumentError $ 'Colors may not be instantiated'.
}.

Colors on: '%' do: {:arr
  ^me message: 'paint:' arguments: arr.
}.

Colors on: 'paint:' do: {:str:*options
  var cache is my cache.
  str is str toString.
  ^(my mode = 0) | (options count = 0) | (str = '')
    either: {\ str }
    or: {
      (options count = 1) & (Reflect isObject: options @ 0 linkedTo: Array) ifTrue: { options is options head. }.
      ^'<a style="%s">%s</a>' % [(Colors fixSpaceFor: str withStyle: (cache at: options)), str].
    }.
}.

Colors on: 'fixSpaceFor:withStyle:' do: {:&str:&style
  var s is 0.
  var e is 0.
  str length times: {:i
    (str @ i = ' ') not break.
    s +=: 1.
  }.
  (var len is str length - s) times: {:i
    (str @ (len + s - i - 1) = ' ') not break.
    e +=: 1.
  }.
  s + e = 0 ifTrue: {
    ^style.
  }.
  ^'margin-left: %dch; margin-right: %dch;' % [s, e] + style.
}.

Colors on: 'color' do: {:*options
  var mix is Array new.
  var color_seen is False.
  var colors is const ANSI_COLORS_FOREGROUND.
  ^((options toBoolean not) | (my mode = 0))
    either: ''
    or: {\
      options each_v: {:option
        (option type)
           case: 'Symbol' do: {
             (var color is colors at: option) isNil not ifTrue: {
                mix push: color.
                color_seen is \set.
              }, else: {
                (var effect is ANSI_EFFECTS at: option) isNil not ifTrue: {
                  mix push: effect.
                }, else: {
                  thisBlock error: (ArgumentError $ ('Unknown color or effect %s' % [option])).
                }.
              }.
        }, case: 'Array' do: {
            (option count = 3) & (option fmap: {:v ^Reflect isObject: v linkedTo: Number.}, all) ifTrue: {
              mix push: (var x is Colors message: 'rgb' arguments: option + [color_seen]).
              color_seen is \set.
            }, else: {
              thisBlock error: ArgumentError $ 'Array argument must contain 3 numbers'.
            }.
        }, case: 'Number' do: {
            var int is option floor.
            int between: 30 and: 49, ifTrue: {color_seen is \set.}.
            mix push: int.
        }, case: 'Nil' do: {
            color_seen is \set.
        }, default: {
            thisBlock error: (ArgumentError $ ('Invalid argument %s' % [option])).
        }, switch.
        (color_seen = \set) ifTrue: {
          colors is ANSI_COLORS_BACKGROUND.
          color_seen is True.
        }.
      }.
      Colors wrap: mix.
    }.
}.

Colors on: 'mode:' do: {:val
  my cache clear.
  [0, 8, 16, 256, const TRUE_COLOR] contains: val, ifTrue: { my mode is val. ^me. }.
  (val = True) ifTrue: { my mode is const TRUE_COLOR. ^me. }.
  (val = Nil) ifTrue: { my mode is 0. ^me. }.
  thisBlock error: ArgumentError $ ('Cannot set paint mode to value < $$val >, possible values are: 0xFFFFFF (True), 256, 16, 8, 0 (Nil)').
}.

Colors on: 'wrap:' do: {\:ansi_codes
  (ansi_codes foldl: (\:acc:x \:arg x applyTo: (acc applyTo: arg)) accumulator: NOTHING)().
}.


Colors on: 'rgb' do: {:red:green:blue:background
  # thisBlock error: NotImplementedError $ 'Colors#rgb'.
  var background is Reflect objectExists: 'background', either: { ^background. } or: False.
  ^'%d%s' % (my mode
       case:   8 do: {
      ^[(background either: 4 or: 3), (Colors message: 'rgb_to_ansi:' arguments: [red, green, blue, (False)])].
    }, case:  16 do: {
      ^[(background either: 4 or: 3), (Colors message: 'rgb_to_ansi:' arguments: [red, green, blue, (True)])].
    }, case: 256 do: {
      ^[(background either: 4 or: 3), (Colors rgb_to_256: [red, green, blue])].
    }, case: TRUE_COLOR do: {
      ^[(background either: 4 or: 3), (Colors rgb_true: [red, green, blue])].
    }, default: {\ '' }, switch).
}.

Colors on: 'rgb_to_ansi:' do: {:red:green:blue:use_bright
  var color_pool is RGB_COLORS_ANSI keys.
  use_bright ifTrue: { color_pool is color_pool + (RGB_COLORS_ANSI_BRIGHT keys). }.
  var ansi_color_rgb is color_pool sort: {:col0:col1 ^(Colors rgb_color_distance: [red, green, blue] color: col0) < (Colors rgb_color_distance: [red, green, blue] color: col1). }, last.
  var ret is ''.
  (var ansi_color is RGB_COLORS_ANSI at: ansi_color_rgb) isNil not ifTrue: {
    ret is ANSI_COLORS at: ansi_color.
  }, else: {
    ansi_color is RGB_COLORS_ANSI_BRIGHT at: ansi_color_rgb.
    ret is '%s;1' % [(ANSI_COLORS at: ansi_color)].
  }.
  ^ret.
}.

Colors on: 'rgb_color_distance:color:' do: {:rgb1:rgb2
  ^[rgb1, rgb2] zip foldl: {:acc:x
    ^acc + (((x @ 0) - (x @ 1)) pow: 2).
  } accumulator: 0.
}.

Colors on: 'effect:' do: {:effect
  ^ANSI_EFFECTS at: effect.
}.

var SComp is CodeBlock new.
SComp on: 'fromBlock:' do: {:blk ^me cnew: {blk => blk.}.}.
SComp on: 'applyTo:' do: {:arg ^my blk applyTo: arg.}.
SComp on: 'applyAll:' do: {:args ^me message: 'applyTo:' arguments: args.}.
SComp on: '+' do: {\:self:other
  var compose_call is const compose_call.
  ^other isA: SComp, either: {\
    ^const SComp fromBlock: self `compose_call` other.
  } or: {
    ^const SComp fromBlock: \:s self(other) + s.
  }.
}.
SComp on: 'toString' do: { ^me(''). }.
SComp on: 'length' do: { ^me('') length. }.

Colors on: 'fwrap:' do: {:self:p
  ^const SComp fromBlock: {:s
    s = '' ifTrue: { ^s. }.
    var p is const self wrap: [const p].
    ^'<a style="%s">%s</a>' % [(const self fixSpaceFor: s withStyle: p), s trim].
  }.
}.
Colors on: 'fwrape:' do: {:self:e ^const SComp fromBlock: e.}.
Colors on: 'simple:background:' do: {:self:name:bg
  name is name toSymbol.
  ^(var p is ANSI_EFFECTS at: name) isNil not
    either: {
      ^self fwrape: p.
      # ^'<%s>' % [name].
    }
    or: {
      ^(var p is ANSI_COLORS at: name) isNil not
        either: { ^self fwrap: p. }
        or: {\ '' }.
    }.
}.

Colors on: 'stripColors:' do: {\:str
  (str ~ 's/<[^>]+>//g')
}.

Colors on: 'respondTo:' do: {:name ^me simple: name background: False. }.

import export: Colors as: 'Colors'.
