import Library/Data/SwitchCase.

#:language XFrozen

var ast2ctrcode is {:self:ast:curindent:options
  options is options or: Map.
  var max_line_length is options at: 'max_line_length', or: 80.
  var indent_s        is ' ' * (options at: 'indent_length', or: 2).
  var pkwmsgs         is options at: 'parenthesize_kwmsgs', or: False.
  curindent is curindent or: 0.
  ^(frozen __ is
    case: 'LTRNUM' do: {
      ^ast value.
    },
    case: 'LTRSTRING' do: {
      var value is ast value.
      ^'\'%s\'' % [value escape: '\n\''].
    },
    case: 'LTRNIL' do: {
      ^'Nil'.
    },
    case: 'LTRBOOLTRUE' do: {
      ^'True'.
    },
    case: 'LTRBOOLFALSE' do: {
      ^'False'.
    },
    case: 'REFERENCE' do: {
      var value is ast value.
      ^(frozen __ is
        case: 'My'     do: {\ 'my %s' },
        case: 'Var'    do: {\ 'var %s' },
        case: 'Const'  do: {\ 'const %s' },
        case: 'Frozen' do: {\ 'frozen %s' },
        default: {\ '%s' }) switch: ast modifier, % [value].
    },
    case: 'EXPRMESSAGE' do: {
      var rec is self[ast @ 0, curindent, options].
      var ct is ast count.
      rec = 'me' ifTrue: {
        (ct > 0) ifTrue: {
          (ast @ 1) type = 'KWMESSAGE' ifTrue: {
            rec is ''.
          }.
        }.
      }.

      ct - 1 times: {:i
        var s is ast @ (i + 1).
        var rv is ' ' + self[s, curindent, options].
        (rec length > max_line_length) ifTrue: {
          (rec split: '\n', last) length + rv length > max_line_length ifTrue: {
            rec +=: '\n' + (indent_s * curindent).
          }.
        }.
        rec +=: rv.
        i !=: ct - 2, & (s type = 'KWMESSAGE') ifTrue: {
          pkwmsgs ifTrue: {
            &&rec is '(${{rec}}$)'.
          } ifFalse: {
	          s value !=: 'applyAll:', ifTrue: {
                    rec +=: ','.
	          }.
          }.
        } ifFalse: {
          pkwmsgs ifTrue: {
            &&rec is '(${{rec}}$)'.
          }.
        }.
      }.
      ^rec.
    },
    case: 'UNAMESSAGE' do: {
      ^ast value.
    },
    case: 'BINMESSAGE' do: {
      ^ast value + ' ' + self[ast @ 0, curindent, options].
    },
    case: 'KWMESSAGE' do: {
      ast value = 'applyAll:' ifTrue: {
        # single expression, return [...args]
        ^self[ast @ 0, curindent, options].
      }.
      var value is ast value split: ':'.
      var code is Array < ''.
      curindent +=: 1.
      value each: {:i:x
        var tc is '%s: %s ' % [x, self[ast @ i, curindent, options]].
        var tchead is tc split: '\n', head.
        (code last length + tchead length > max_line_length) ifTrue: { # ...\n <code> <tc>
          code push: ''.
        }.
        code last +=: tc.
      }.
      var indent is indent_s * curindent.
      code is (code join: '\n' + indent).
      curindent -=: 1.
      ^code rightTrim.
    },
    case: 'EXPRASSIGNMENT' do: {
      var ref is self[(ast at: 0), curindent, options].
      var _value is self[(ast at: 1), curindent, options].
      ^_value length > 0 either: { ^'%s is %s' % [ref, _value]. } or: ref.
    },
    case: 'SYMBOL' do: {
      ^$!ast.
    },
    case: 'NESTED' do: {
      var code is '('.
      var ps is ast at: 0.
      curindent +=: 1.
      var tcode is self[ps, curindent, options].
      tcode length > max_line_length ifTrue: { code +=: '\n' + (indent_s * curindent). }.
      code +=: tcode.
      curindent -=: 1.
      ^code + ')'.
    },
    case: 'CODEBLOCK' do: {
      var ps is ast at: 0.
      var ins is ast at: 1.
      var indentEnd is True.
      var fmt is ast modifier = 'My' either: {
        ^ins instrCount = 1 either: {
          indentEnd is False.
          var in is ins @ 0.
          (frozen iskwm is {:self:node
            node type = 'KWMESSAGE' ifTrue: {
              ^ True.
            }.
            var yes is False.
            node count times: {:i
              var n is node @ i.
              self[n] ifTrue: {
                yes is True.
                yes break.
              }.
            }.
            ^yes.
          })[in] ifTrue: {
            ^'(\\%:L%s%:L%s)'.
          } ifFalse: {
            ^'\\%:L%s%:L%s'.
          }.
        } or: '{\\%:L%s%:L\n%s}'.
      } or: '{%:L%s%:L\n%s}'.
      var eindent is indent_s * curindent.
      curindent +=: 1.
      var cindent is indentEnd either: { ^'\n' + (indent_s * curindent). } or: ' '.
      var dot is indentEnd either: '.' or: ''.
      var res is fmt % ['',
              (Array new fill: ps count with: \:x ':' + ((frozen decodeF is {:node ^node value = '' either: {^self[node, curindent, options].} or: node value.})[ps @ x])),
              cindent,
              cindent,
              (Array new fill: ins count with: \:x self[ins @ x, curindent, options] + dot),
              eindent
            ].
      curindent -=: 1.
      ^res.
    },
    case: 'PROGRAM' do: {
      ^(Array new fill: ast count with: \:x self[ast @ x, curindent, options] + '.') join: '\n' + (indent_s * curindent).
    },
    case: 'ENDOFPROGRAM' do: { ^''. },
    case: 'RETURNFROMBLOCK' do: { ^'^' + self[ast @ 0, curindent, options]. },
    case: 'IMMUTABLE' do: {
      var code is Array < '['.
      var ps is ast at: 0.
      var pcount is ps count.
      var newlined is False.
      (Array new fill: pcount with: \:i self[ps @ i, curindent, options]) each_v: {:gen
        var tcode is code last + gen + ', '.
        tcode split: '\n', last length > max_line_length ifTrue: {
          code unshift: (indent_s * (curindent + 1)) + (code shift skip: 1).
          code unshift: '['.
          code push: (indent_s * (curindent + 1)) + gen + ', '.
          newlined is True.
        } ifFalse: { code last +=: gen + ', '. }.
      }.
      pcount > 0 ifTrue: { code put: (code last from: 0 to: code last length - 2) at: code count - 1. }.
      code last split: '\n', last length > max_line_length ifTrue: { code push: ''. }.
      newlined ifTrue: {
        code push: (indent_s * curindent) + ']'.
      } ifFalse: {
        code last +=: ']'.
      }.
      ^code filter_v: \:x x trim length, join: '\n'.
    },
    case: 'RAW' do: {
      ^((frozen _ is
          case: 'None' do: {\ '%s'},
          case: 'My'   do: {\ '$(%s)'},
          default:         {
            ^'%s'.
          }
        ) switch: ast modifier) % [self[ast @ 0, curindent, options]].
    },
    case: 'EMBED' do: {
      ast modifier = 'Var' ifTrue: {
        ^ast at: 1, toString.
      }.
      var qq is ast at: 0.
      ^'$`(' + self[qq, curindent, options] + ')'.
    },
    case: 'LISTCOMP' do: {
      var expr is ast at: 0.
      var generator is ast at: 1.
      var noptions is options copy put: True at: 'parenthesize_kwmsgs'.
      var gencode is ''.
      {
        var pcount is generator count.
        (Array new fill: pcount with: {:i
          var node is generator @ i.
          node type = 'NESTED' ifTrue: {
            var candidate is node at: 0.
            (candidate type = 'EXPRMESSAGE')
              & (candidate at: 0, type = 'REFERENCE')
              & (candidate at: 0, value = 'me')
              & (candidate at: 1, type = 'KWMESSAGE')
              ifTrue: {
                noptions put: False at: 'parenthesize_kwmsgs'.
                ^'(' + self[candidate, curindent, noptions] + ')'.
              }.
          }.
          ^self[node, curindent, noptions].
        }) each_v: {:gen
          var tgencode is gencode + gen + ', '.
          tgencode split: '\n', last length > max_line_length ifTrue: { tgencode is gencode + '\n' + (indent_s * (curindent + 1)) + gen + ', '. }.
          gencode is tgencode.
        }.
        pcount > 0 ifTrue: { gencode is gencode from: 0 to: gencode length - 2. }.
        gencode split: '\n', last length > max_line_length ifTrue: { gencode +=: '\n'. }.
      } catch: {}, run.
      var predcode is ''.
      {
        var predicate is ast at: 2.
        var pcount is predicate count.
        (Array new fill: pcount with: \:i self[predicate @ i, curindent, noptions]) each_v: {:gen
          var tpredcode is predcode + gen + ', '.
          tpredcode split: '\n', last length > max_line_length ifTrue: { tpredcode is predcode + '\n' + (indent_s * (curindent + 1)) + gen + ', '. }.
          predcode is tpredcode.
        }.
        pcount > 0 ifTrue: { predcode is predcode from: 0 to: predcode length - 2. }.
        predcode split: '\n', last length > max_line_length ifTrue: { predcode +=: '\n'. }.
      } catch: { }, run.
      var exprv is '['.
      expr type = 'NESTED' ifTrue: {
        exprv +=: self[expr @ 0, curindent, options].
      } ifFalse: {
        exprv +=: self[expr, curindent, options].
      }.
      gencode = '' ifFalse: {
        var exprvb is exprv + ''.
        exprv +=: ',, ' + gencode.
        exprv split: '\n', last length > max_line_length ifTrue: {
          exprv is '${{exprvb}}$,,\n${{indent_s * (curindent + 1)}}$$$gencode'.
        }.
      }.
      predcode = '' ifFalse: {
        var exprvb is exprv + ''.
        exprv +=: ',, ' + predcode.
        exprv split: '\n', last length > max_line_length ifTrue: {
          exprv is '${{exprvb}}$,,\n${{indent_s * (curindent + 1)}}$$$predcode'.
        }.
      }.
      exprv +=: ']'.
      ^exprv.
    },
    default: { errPen red writeln: '$$ast is not unparsable at the moment ( because of $$value )', resetColor. }) switch: ast type.
}.
